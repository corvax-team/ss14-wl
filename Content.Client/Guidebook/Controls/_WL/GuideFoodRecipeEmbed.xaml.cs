using System.Diagnostics.CodeAnalysis;
using System.Linq;
using Content.Client.Guidebook.Richtext;
using Content.Client.Message;
using Content.Client.UserInterface.ControlExtensions;
using Content.Shared.Chemistry.Reaction;
using Content.Shared.Chemistry.Reagent;
using Content.Shared.FixedPoint;
using Content.Shared.Kitchen;
using JetBrains.Annotations;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.Guidebook.Controls._WL;

/// <summary>
///     Control for embedding a food recipe into a guidebook.
/// </summary>
[UsedImplicitly, GenerateTypedNameReferences]
public sealed partial class GuideFoodRecipeEmbed : BoxContainer, IDocumentTag, ISearchableControl
{
    [Dependency] private readonly IPrototypeManager _prototype = default!;
    [Dependency] private readonly IEntitySystemManager _systemManager = default!;

    private readonly SpriteSystem _sprite;

    private readonly SpriteSpecifier.Rsi BeakerContent;
    private readonly SpriteSpecifier.Rsi Beaker;
    public GuideFoodRecipeEmbed()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
        MouseFilter = MouseFilterMode.Stop;
        _sprite = _systemManager.GetEntitySystem<SpriteSystem>();

        BeakerContent = new SpriteSpecifier.Rsi(new("/Textures/Objects/Specific/Chemistry/beaker_large.rsi"), "beakerlarge6");
        Beaker = new(new("/Textures/Objects/Specific/Chemistry/beaker_large.rsi"), "beakerlarge");
    }

    public GuideFoodRecipeEmbed(FoodRecipePrototype recipe) : this()
    {
        GenerateControl(recipe);
    }

    public bool CheckMatchesSearch(string query)
    {
        return this.ChildrenContainText(query);
    }

    public void SetHiddenState(bool state, string query)
    {
        Visible = CheckMatchesSearch(query) ? state : !state;
    }

    public bool TryParseTag(Dictionary<string, string> args, [NotNullWhen(true)] out Control? control)
    {
        control = null;
        if (!args.TryGetValue("Recipe", out var id))
        {
            Logger.Error("Recipe embed tag is missing recipe prototype argument");
            return false;
        }

        if (!_prototype.TryIndex<FoodRecipePrototype>(id, out var recipe))
        {
            Logger.Error("Error in GuideFoodRecipeEmbed");
            return false;
        }
        GenerateControl(recipe);
        control = this;
        return true;
    }

    private void GenerateControl(FoodRecipePrototype recipe)
    {
        NameBackground.PanelOverride = new StyleBoxFlat
        {
            BackgroundColor = Color.Purple
        };
        RecipeName.SetMarkup("[color=white]" + _prototype.Index<EntityPrototype>(recipe.Result).Name + "[/color]");

        //Products
        var reactants = recipe.IngredientsReagents.Concat(recipe.IngredientsSolids);
        foreach (var reactant in reactants)
        {
            if (_prototype.TryIndex<EntityPrototype>(reactant.Key, out var entProto))
            {
                RecipeReactants.AddChild(GetElement(entProto, reactant.Value));
            }
            else if (_prototype.TryIndex<ReagentPrototype>(reactant.Key, out var reagentProto))
            {
                RecipeReactants.AddChild(GetElement(reagentProto, reactant.Value));
            }
        }

        //Result
        if (_prototype.TryIndex<EntityPrototype>(recipe.Result, out var resultProto))
            RecipeProducts.AddChild(GetElement(resultProto, 1));

        //Cooking time
        CookingTypeDesc.SetMarkup($"{recipe.CookTime} {Loc.GetString("guidebook-food-recipe-embed-time-prefix")}");
    }

    public Control GetElement(EntProtoId entProto, FixedPoint2 count)
        => GetElement(entProto.Id, count);

    public Control GetElement(string entProto, FixedPoint2 count)
    {
        var entityProto = _prototype.Index<EntityPrototype>(entProto);

        return GetElement(entityProto, count);
    }

    public Control GetElement(EntityPrototype entityProto, FixedPoint2 count)
    {
        var textures = new List<TextureRect>();

        if (entityProto.Components.Values
            .FirstOrDefault(comp => comp.Component is SpriteComponent)?.Component is not SpriteComponent spriteComp)
            return new Label() { Text = "ERROR while seeking sprite component" };

        foreach (var layer in spriteComp.AllLayers)
        {
            var path = "";
            var state = "";

            if (layer.Texture != null)
            {
                textures.Add(new()
                {
                    Texture = layer.Texture
                });
                continue;
            }
            else if (layer.RsiState.Name != null)
            {
                if (layer.ActualRsi != null)
                {
                    path = layer.ActualRsi.Path.CanonPath;
                }
                else if (spriteComp.BaseRSI != null)
                {
                    path = spriteComp.BaseRSI.Path.CanonPath;
                }

                state = layer.RsiState.Name;
            }

            textures.Add(new()
            {
                Texture = _sprite.Frame0(new SpriteSpecifier.Rsi(new(path), state))
            });
        }

        var prefix = Loc.GetString("guidebook-food-recipe-embed-entity-prefix");
        var desc = GetMarkupDescString(entityProto.Name, count, prefix);

        return GetElement(textures, desc);
    }

    public Control GetElement(ReagentPrototype reagent, FixedPoint2 count)
    {
        var textures = new List<TextureRect>()
        {
            new()
            {
                Texture = _sprite.Frame0(Beaker)
            },
            new()
            {
                Texture = _sprite.Frame0(BeakerContent),
                Modulate = reagent.SubstanceColor
            }
        };

        var prefix = Loc.GetString("guidebook-food-recipe-embed-reagent-prefix");
        var desc = GetMarkupDescString(reagent.LocalizedName, count, prefix);

        return GetElement(textures, desc);
    }

    /// <param name="name"></param>
    /// <param name="count"></param>
    /// <param name="countPrefix"></param>
    /// <returns>
    ///  Строка формата: "[имя] [количество] [префикс]".
    ///  <code>
    ///   сырая котлета 5 шт.
    ///   вода 6 ед.
    ///  </code>
    /// </returns>
    /// <remarks>
    ///  Цвет префикса и количества - #7d7d7d
    /// </remarks>
    public static string GetMarkupDescString(string name, FixedPoint2 count, string countPrefix)
    {
        return $"{name} [color=#7d7d7d]{count} {countPrefix}[/color]";
    }

    /// <summary>
    /// Создаёт элемент текстура-описание.
    /// </summary>
    /// <param name="textures">Список текстур по слоям. Нулевому индексу соответствует высший слой.</param>
    /// <param name="desc">Описание, отображаемое под текстурой.</param>
    /// <returns>
    ///  BoxContainer в  виде:
    ///
    ///  <code>
    ///  > Текстура
    ///  > Описание
    ///  </code>
    /// </returns>
    public static Control GetElement(List<TextureRect> textures, string? desc)
    {
        var mainBox = new BoxContainer()
        {
            Margin = new Thickness(3, 3),
            Orientation = LayoutOrientation.Vertical,
            HorizontalAlignment = HAlignment.Center
        };

        var texture = AddTextureChildRecursive(textures);
        texture.HorizontalAlignment = HAlignment.Center;
        mainBox.AddChild(texture);

        if (desc != null)
        {
            var richName = new RichTextLabel()
            {
                HorizontalAlignment = HAlignment.Center
            };
            richName.SetMarkup(desc);

            mainBox.AddChild(richName);
        }
        return mainBox;
    }

    public static TextureRect AddTextureChildRecursive(List<TextureRect> textures)
    {
        for (var i = 1; i < textures.Count; i++)
        {
            textures[i - 1].AddChild(textures[i]);
        }

        return textures[0];
    }
}
